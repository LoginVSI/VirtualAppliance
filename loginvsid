#!/bin/bash
### BEGIN INIT INFO
# Provides:          loginvsid
# Required-Start:    
# Required-Stop:     
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: loginvsid
# Description:       loginvsid
### END INIT INFO

netadapters=$(ip -o link show | while read -r num dev fam mtulabel mtusize qlabel queu statelabel state modelabel mode grouplabel group qlenlabel qlen maclabel mac brdlabel brcast; do 
        if [[ ${mac} != brd && ${mac} != 00:00:00:00:00:00 && ${dev} != br-*  && ${dev} != veth* ]]; then
            echo ${dev%/*} | awk '{split($1,n,":");print n[1]}'; 
        fi     
    done
    )   
for netadapter in $(echo $netadapters); do
    ip=$(ip -o addr show $netadapter primary scope global | while read -r num dev fam addr rest; do 
        if [[ ${dev} != docker* ]]; then
            echo ${addr%/*}; 
        fi       
    done
    )
    allowed_ips+=";https://$ip" 
done

start() {
  export fqdn=$(hostname).$(domainname)
  cd /loginvsi
  if [ ! -z $(docker ps -a -f name=portainer --format "{{.Image}}") ]; then
    echo "Portainer container already exists, not recreating.."
  else    
    docker run -d -p 9000:9000 --restart=always -v /loginvsi/img:/images -v /certificates:/certs -v /var/run/docker.sock:/var/run/docker.sock -v /opt/portainer:/data --name portainer portainer/portainer --ssl --sslkey /certs/${fqdn}.key.un --sslcert /certs/${fqdn}.crt --admin-password $(cat /root/.portainer) -H unix:///var/run/docker.sock  
  fi
  
  #if [ ! -z $(docker ps -a -f name=appliancemanagement --format "{{.Image}}") ]; then
  #  echo "ApplianceManagement container already exists, not recreating.."
  #else  
  #  docker service create --name appliancemanagement --publish 8000:8000 --secret ADMIN_PASSWORD --secret APPLIANCEMANAGEMENT_PFX --secret APPLIANCEMANAGEMENT_PFX_PASSWORD loginvsi/appliancemanagement:stable
  #fi

  sed -i '/ALLOWED_CLIENT_URLS=/d' /loginvsi/.env
  sed -i '/COMPOSE_PROJECT_NAME=/d' /loginvsi/.env
  echo COMPOSE_PROJECT_NAME=loginvsi >>/loginvsi/.env
  echo ALLOWED_CLIENT_URLS=https://$fqdn$allowed_ips >>/loginvsi/.env
  
  export $(cat .env); docker stack deploy --resolve-image never --compose-file ./docker-compose.yml VSI
  sleep 5 &>/dev/null
  TOTAL=$(docker stack services VSI --format "{{.Replicas}}" | wc -l)

  MAXCOUNT=30
  COUNT=0
  while [ $COUNT -le $MAXCOUNT ];
  do    
    COUNT=$((COUNT+1))    
    RUNNING=$(docker stack services VSI --format "{{.Replicas}}" | grep "1/1" | wc -l)    
    if [ $TOTAL -eq $RUNNING ]; then
      printf "Starting LoginVSI services: \e[32m[DONE]\e[39m \r\n" 
      DONE="true" 
      break
    else
      printf "Starting LoginVSI services: \e[36m[%s]\e[39m\r\n" "$RUNNING/$TOTAL"
    fi
    sleep 30 &>/dev/null  
  done
  if [ -z $DONE ]; then
    echo "Starting services timedout after $MAXCOUNT seconds"
  else       
    services=$(docker service ps -q VSI_contentdelivery)
    for f in $services; do        
      container=$(docker inspect --format "{{.Status.ContainerStatus.ContainerID}}" $f) # needs to be checked when more then 1 instance of contentdelivery is running
      if [ -f /certificates/CA.crt ]; then
        echo "Copying CA.crt to contentDelivery..."      
        docker cp /certificates/CA.crt $container:/app/wwwroot/content
      fi            
    done              
  fi  
}

stop() { 
  printf "Stopping LoginVSI services \r\n"
  #docker stop $(docker ps -qf name=VSI_) &>/dev/null    
  #printf "Stopping LoginVSI services: \e[32m[DONE]\e[39m \r\n"
}

restart() {
  docker stack rm VSI  
  printf "Waiting for networks to clear up...\r\n"
  while [[ ! -z $(docker network ls -qf name=VSI_) ]];
  do    
    docker network prune -f &>/dev/null
    sleep 5
  done
 printf "Waiting for networks to clear up... \e[32m[DONE]\e[39m \r\n"
 start
}

status() {   
  docker service ls -f name=VSI_   
}

update() {
  cd /loginvsi
  if [ -d /loginvsi/update ]; then
    rm -rf /loginvsi/update
  fi

  git clone https://github.com/LoginVSI/VirtualAppliance.git update

  # execute update script
  chmod +x update/update
  update/update
  
  loginvsid start
  rm -rf /loginvsi/update

}

offlineupdate() {
  cd /loginvsi
  
  read -ep "Make sure the update iso is connected to the VM, press enter to continue" emtpy
  [[ ! -d /mnt/cdrom ]] && mkdir -p /mnt/cdrom
  mount /dev/cdrom /mnt/cdrom

  if [ ! -f /mnt/cdrom/update/update ]; then
    echo "Could not find updater, probably the update iso was not mounted properly."
    exit 1
  fi
  if [ -d /loginvsi/update ]; then
    rm -rf /loginvsi/update
  fi

  cp -rf /mnt/cdrom/update/ .

  # execute update script
  chmod +x update/update
  update/update offline
  
  umount /mnt/cdrom
  rm -rf /mnt/cdrom

  loginvsid start
  rm -rf /loginvsi/update

}

case "$1" in
  start|stop|restart|update|status|offlineupdate) "$1" ;;
esac