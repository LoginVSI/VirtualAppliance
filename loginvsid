#!/bin/bash
### BEGIN INIT INFO
# Provides:          loginvsid
# Required-Start:    
# Required-Stop:     
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: loginvsid
# Description:       loginvsid
### END INIT INFO

netadapters=$(ip -o link show | while read -r num dev fam mtulabel mtusize qlabel queu statelabel state modelabel mode grouplabel group qlenlabel qlen maclabel mac brdlabel brcast; do 
        if [[ ${mac} != brd && ${mac} != 00:00:00:00:00:00 && ${dev} != br-*  && ${dev} != veth* ]]; then
            echo ${dev%/*} | awk '{split($1,n,":");print n[1]}'; 
        fi     
    done
    )   
for netadapter in $(echo $netadapters); do
    ip=$(ip -o addr show $netadapter primary scope global | while read -r num dev fam addr rest; do 
        if [[ ${dev} != docker* ]]; then
            echo ${addr%/*}; 
        fi       
    done
    )
    allowed_ips+=";https://$ip" 
done

start() {
  export fqdn=$(hostname).$(domainname)
  cd /loginvsi
  if [ ! -z $(docker ps -a -f name=portainer --format "{{.Image}}") ]; then
    echo "Portainer container already exists, not recreating.."
  else    
    docker run -d -p 9000:9000 --restart=always -v /loginvsi/img:/images -v /certificates:/certs -v /var/run/docker.sock:/var/run/docker.sock -v /opt/portainer:/data --name portainer portainer/portainer --ssl --sslkey /certs/${fqdn}.key.un --sslcert /certs/${fqdn}.crt --admin-password $(cat /root/.portainer) -H unix:///var/run/docker.sock  
  fi
  
  #if [ ! -z $(docker ps -a -f name=appliancemanagement --format "{{.Image}}") ]; then
  #  echo "ApplianceManagement container already exists, not recreating.."
  #else  
  #  docker service create --name appliancemanagement --publish 8000:8000 --secret ADMIN_PASSWORD --secret APPLIANCEMANAGEMENT_PFX --secret APPLIANCEMANAGEMENT_PFX_PASSWORD loginvsi/appliancemanagement:stable
  #fi

  sed -i '/ALLOWED_CLIENT_URLS=/d' /loginvsi/.env
  sed -i '/COMPOSE_PROJECT_NAME=/d' /loginvsi/.env
  echo COMPOSE_PROJECT_NAME=loginvsi >>/loginvsi/.env
  echo ALLOWED_CLIENT_URLS=https://$fqdn$allowed_ips >>/loginvsi/.env
  
  export $(cat .env); docker stack deploy --resolve-image never --compose-file ./docker-compose.yml VSI
  sleep 5 &>/dev/null
  TOTAL=$(docker stack services VSI --format "{{.Replicas}}" | wc -l)

  MAXCOUNT=30
  COUNT=0
  while [ $COUNT -le $MAXCOUNT ];
  do    
    COUNT=$((COUNT+1))    
    RUNNING=$(docker stack services VSI --format "{{.Replicas}}" | grep "1/1" | wc -l)    
    if [ $TOTAL -eq $RUNNING ]; then
      printf "Starting LoginVSI services: \e[32m[DONE]\e[39m \r\n" 
      DONE="true" 
      break
    else
      printf "Starting LoginVSI services: \e[36m[%s]\e[39m\r\n" "$RUNNING/$TOTAL"
    fi
    sleep 30 &>/dev/null  
  done
  if [ -z $DONE ]; then
    echo "Starting services timedout after $MAXCOUNT seconds"
  else       
    services=$(docker service ps -q VSI_contentdelivery)
    for f in $services; do        
      container=$(docker inspect --format "{{.Status.ContainerStatus.ContainerID}}" $f) # needs to be checked when more then 1 instance of contentdelivery is running
      if [ -f /certificates/CA.crt ]; then
        echo "Copying CA.crt to contentDelivery..."      
        docker cp /certificates/CA.crt $container:/app/wwwroot/content
      fi            
    done              
  fi  
}

stop() { 
  printf "Stopping LoginVSI services \r\n"
  #docker stop $(docker ps -qf name=VSI_) &>/dev/null    
  #printf "Stopping LoginVSI services: \e[32m[DONE]\e[39m \r\n"
}

restart() {
  docker stack rm VSI  
  printf "Waiting for networks to clear up...\r\n"
  while [[ ! -z $(docker network ls -qf name=VSI_) ]];
  do    
    docker network prune -f &>/dev/null
    sleep 5
  done
 printf "Waiting for networks to clear up... \e[32m[DONE]\e[39m \r\n"
 start
}

status() {   
  docker service ls -f name=VSI_   
}

update() {
  cd /loginvsi
  if [ -d /loginvsi/update ]; then
    rm -rf /loginvsi/update
  fi
  if [ -d /loginvsi/hosting ]; then
    rm -rf /loginvsi/hosting
  fi 
  # Get the hosting and appliance repo's
  git clone https://github.com/LoginVSI/VirtualAppliance.git update
  git clone -b stable https://github.com/LoginVSI/Hosting.git hosting
  # copy latest compose file from hosting
  cp -f hosting/latest/Production/InternalDB/docker-compose.yml /loginvsi
  
  #copy latest loginvsi folder
  cp -f -r update/loginvsi/* /loginvsi/

  # copy loginvsid.service and loginvsid
  cp -f update/loginvsid /usr/bin/
  cp -f update/loginvsid.service /etc/systemd/system/
  
  chmod +x /usr/bin/loginvsid
  chown root:root /usr/bin/loginvsid
  systemctl disable loginvsid &>/dev/null
  systemctl enable loginvsid &>/dev/null

  # Check if any new entries in new .env and add them to the current .env
  for i in $(diff -y hosting/latest/Production/InternalDB/.env .env | grep ">" | cut -d ">" -f2 | xargs); do
    echo $i >> .env
  done

  # create new db folders if needed
   for f in $(cat /loginvsi/docker-compose.yml | grep "{DB_ROOT}")
    do 
        folder=$(echo $f | cut -d"-" -f2 | cut -d"/" -f2 | cut -d":" -f1) 
        if [ ! -z $folder ]; then
          if [ ! -d /loginvsi/data/$folder ]; then        
              mkdir /loginvsi/data/$folder; 
          fi
        fi
    done

  # pull the new images from dockerhub
  echo $(cat /root/.play) | base64 -d | docker login -u vsiplayaccount --password-stdin
  docker-compose pull 2>&1
  docker logout 2>&1

  loginvsid start
  rm -rf /loginvsi/update
  rm -rf /loginvsi/hosting
}

case $1 in
  start|stop|restart|update|status) "$1" ;;
esac